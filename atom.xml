<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Live long and prosper</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-21T15:00:18.514Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lance</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>结合Vue源码谈谈发布-订阅模式</title>
    <link href="http://yoursite.com/2019/05/21/pub-sub/"/>
    <id>http://yoursite.com/2019/05/21/pub-sub/</id>
    <published>2019-05-21T09:28:40.000Z</published>
    <updated>2019-05-21T15:00:18.514Z</updated>
    
    <content type="html"><![CDATA[<p>最近的工作学习中接触到了发布-订阅模式。该思想编程中的应用也是很广泛的, 例如在 <code>Vue</code>中也大量使用了该设计模式,所以会结合Vue的源码和大家谈谈自己粗浅的理解.</p><h2 id="发布订阅模式主要包含哪些内容呢"><a href="#发布订阅模式主要包含哪些内容呢" class="headerlink" title="发布订阅模式主要包含哪些内容呢?"></a>发布订阅模式主要包含哪些内容呢?</h2><ol><li>发布函数，发布的时候执行相应的回调</li><li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li><li>一个缓存订阅者以及订阅者的回调函数的列表</li><li>取消订阅(需要分情况讨论)</li></ol><p>这么看下来,其实就像 <code>JavaScript</code> 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.<br><a id="more"></a></p><h2 id="我们先按照上面的内容自己实现一个-Observer-对象如下"><a href="#我们先按照上面的内容自己实现一个-Observer-对象如下" class="headerlink" title="我们先按照上面的内容自己实现一个 Observer 对象如下:"></a>我们先按照上面的内容自己实现一个 <code>Observer</code> 对象如下:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//用于存储订阅的事件名称以及回调函数列表的键值对</span><br><span class="line">function Observer() &#123;</span><br><span class="line">    this.cache = &#123;&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//key:订阅消息的类型的标识（名称），fn收到消息之后执行的回调函数</span><br><span class="line">Observer.prototype.on = function (key,fn) &#123;</span><br><span class="line">    if(!this.cache[key])&#123;</span><br><span class="line">        this.cache[key]=[]</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache[key].push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//arguments 是发布消息时候携带的参数数组</span><br><span class="line">Observer.prototype.emit = function (key) &#123;</span><br><span class="line">    if(this.cache[key]&amp;&amp;this.cache[key].length&gt;0)&#123;</span><br><span class="line">        var fns = this.cache[key]</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0;i&lt;fns.length;i++)&#123;</span><br><span class="line">        Array.prototype.shift.call(arguments)</span><br><span class="line">        fns[i].apply(this,arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// remove 的时候需要注意，如果你直接传入一个匿名函数fn，那么你在remove的时候是无法找到这个函数并且把它移除的，变通方式是传入一个</span><br><span class="line">//指向该函数的指针，而 订阅的时候存入的也是这个指针</span><br><span class="line">Observer.prototype.remove = function (key,fn) &#123;</span><br><span class="line">    let fns = this.cache[key]</span><br><span class="line">    if(!fns||fns.length===0)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //如果没有传入fn，那么就是取消所有该事件的订阅</span><br><span class="line">    if(!fn)&#123;</span><br><span class="line">        fns=[]</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        fns.forEach((item,index)=&gt;&#123;</span><br><span class="line">            if(item===fn)&#123;</span><br><span class="line">                fns.splice(index,1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = new Observer()</span><br><span class="line">obj.on(&apos;hello&apos;,function (a,b) &#123;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;)</span><br><span class="line">obj.emit(&apos;hello&apos;,1,2)</span><br><span class="line">//取消订阅事件的回调必须是具名函数</span><br><span class="line">obj.on(&apos;test&apos;,fn1 =function () &#123;</span><br><span class="line">    console.log(&apos;fn1&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">obj.on(&apos;test&apos;,fn2 = function () &#123;</span><br><span class="line">    console.log(&apos;fn2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">obj.remove(&apos;test&apos;,fn1)</span><br><span class="line">obj.emit(&apos;test&apos;)</span><br></pre></td></tr></table></figure><p>为什么会使用发布订阅模式呢?  它的优点在于:</p><ol><li>实现<strong>时间上的解耦</strong>(组件,模块之间的异步通讯)</li><li><strong>对象之间的解耦</strong>,交由发布订阅的对象管理对象之间的耦合关系.</li></ol><h2 id="发布-订阅模式在-Vue中的应用"><a href="#发布-订阅模式在-Vue中的应用" class="headerlink" title="发布-订阅模式在 Vue中的应用"></a>发布-订阅模式在 <code>Vue</code>中的应用</h2><ol><li><code>Vue</code>的实例方法中的应用:(当前版本:2.5.16)<ul><li><a href="https://cn.vuejs.org/v2/api/#vm-on" target="_blank" rel="noopener">文档传送门</a></li><li><a href="https://github.com/vuejs/vue/blob/c24f3e4208cd045832002ee9916559f6fe0dc2b5/src/core/instance/events.js" target="_blank" rel="noopener">源码传送门</a></li></ul></li></ol><ul><li>源码节选 :(引入了flow.js用于静态类型检查)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// vm.$on</span><br><span class="line">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">    const hookRE = /^hook:/</span><br><span class="line">    //参数类型为字符串或者字符串组成的数组</span><br><span class="line">    Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123;</span><br><span class="line">        const vm: Component = this</span><br><span class="line">        // 传入类型为数组</span><br><span class="line">        if (Array.isArray(event)) &#123;</span><br><span class="line">            for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">                this.$on(event[i], fn)</span><br><span class="line">                //递归并传入相应的回调</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //</span><br><span class="line">            (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">            // optimize hook:event cost by using a boolean flag marked at registration</span><br><span class="line">            // instead of a hash lookup</span><br><span class="line">            if (hookRE.test(event)) &#123;</span><br><span class="line">                vm._hasHookEvent = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vm</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// vm.$emit</span><br><span class="line"></span><br><span class="line"> Vue.prototype.$emit = function (event: string): Component &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      const lowerCaseEvent = event.toLowerCase()</span><br><span class="line">      if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">        tip(</span><br><span class="line">          `Event &quot;$&#123;lowerCaseEvent&#125;&quot; is emitted in component ` +</span><br><span class="line">          `$&#123;formatComponentName(vm)&#125; but the handler is registered for &quot;$&#123;event&#125;&quot;. ` +</span><br><span class="line">          `Note that HTML attributes are case-insensitive and you cannot use ` +</span><br><span class="line">          `v-on to listen to camelCase events when using in-DOM templates. ` +</span><br><span class="line">          `You should probably use &quot;$&#123;hyphenate(event)&#125;&quot; instead of &quot;$&#123;event&#125;&quot;.`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let cbs = vm._events[event]</span><br><span class="line">    if (cbs) &#123;</span><br><span class="line">      cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs</span><br><span class="line">      const args = toArray(arguments, 1)</span><br><span class="line">      for (let i = 0, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          cbs[i].apply(vm, args)// 执行之前传入的回调</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, `event handler for &quot;$&#123;event&#125;&quot;`)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code>中还实现了<code>vm.$once</code> (监听一次);以及<code>vm.$off</code> (取消订阅) ,大家可以在同一文件中看一下是如何实现的.</p><ol start="2"><li><code>Vue</code>数据更新机制中的应用</li></ol><ul><li>observer每个对象的属性，添加到订阅者容器Dependency(Dep)中，当数据发生变化的时候发出notice通知。</li><li>Watcher：某个属性数据的监听者/订阅者，一旦数据有变化，它会通知指令(directive)重新编译模板并渲染UI</li><li>部分源码如下: <a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank" rel="noopener">源码传送门-observer</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that has this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    def(value, &apos;__ob__&apos;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      const augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through each property and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">   // 属性为对象的时候,observe 对象的属性</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dep对象: 订阅者容器，负责维护watcher<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js" target="_blank" rel="noopener">源码传送门</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []   //存储订阅者 </span><br><span class="line">  &#125;</span><br><span class="line">  // 添加watcher</span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"> // 移除</span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> // 变更通知</span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作中小应用举例"><a href="#工作中小应用举例" class="headerlink" title="工作中小应用举例"></a>工作中小应用举例</h2><ol><li>场景: 基于wepy的小程序. 由于项目本身不是足够的复杂到要使用提供的 <code>redux</code>进行状态管理.但是在不同的组件(不限于父子组件)之间,存在相关联的异步操作.所以在wepy对象上挂载了一个本文最开始实现的Observer对象.作为部分组件之间通信的总线机制:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wepy.$bus = new Observer()</span><br><span class="line">// 然后就可以在不同的模块和组件中订阅和发布消息了</span><br></pre></td></tr></table></figure><h2 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h2><p>当然,发布-订阅模式也是有缺点的. </p><ol><li>创建订阅者本身会消耗内存,订阅消息后,也许,永远也不会有发布,而订阅者始终存在内存中.</li><li>对象之间解耦的同时,他们的关系也会被深埋在代码背后,这会造成一定的维护成本.</li></ol><p>当然设计模式的存在是帮助我们解决特定场景的问题的,学会在正确的场景中使用才是最重要的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的工作学习中接触到了发布-订阅模式。该思想编程中的应用也是很广泛的, 例如在 &lt;code&gt;Vue&lt;/code&gt;中也大量使用了该设计模式,所以会结合Vue的源码和大家谈谈自己粗浅的理解.&lt;/p&gt;
&lt;h2 id=&quot;发布订阅模式主要包含哪些内容呢&quot;&gt;&lt;a href=&quot;#发布订阅模式主要包含哪些内容呢&quot; class=&quot;headerlink&quot; title=&quot;发布订阅模式主要包含哪些内容呢?&quot;&gt;&lt;/a&gt;发布订阅模式主要包含哪些内容呢?&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发布函数，发布的时候执行相应的回调&lt;/li&gt;
&lt;li&gt;订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数&lt;/li&gt;
&lt;li&gt;一个缓存订阅者以及订阅者的回调函数的列表&lt;/li&gt;
&lt;li&gt;取消订阅(需要分情况讨论)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这么看下来,其实就像 &lt;code&gt;JavaScript&lt;/code&gt; 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>hexo+githubPages 建站记录</title>
    <link href="http://yoursite.com/2019/03/20/test-article/"/>
    <id>http://yoursite.com/2019/03/20/test-article/</id>
    <published>2019-03-20T06:45:20.000Z</published>
    <updated>2019-05-21T15:10:59.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用githubPages"><a href="#使用githubPages" class="headerlink" title="使用githubPages"></a>使用githubPages</h2><ol><li>新建仓库,仓库名 <code>你的用户名+github.io</code>;例如我的仓库名是 <code>lance10030.github.io</code>. 要求源自于 <a href="https://help.github.com/en/categories/github-pages-basics" target="_blank" rel="noopener">Github Pages</a>.</li><li>确保本地配置好了<code>github</code>的<code>ssh</code>, <a href="https://juejin.im/post/5ac0a382f265da238533012d" target="_blank" rel="noopener">配置教程</a>.</li><li>项目中配置<code>_config.yml</code>,示例如下<a id="more"></a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:lance10030/lance10030.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ol start="4"><li>按照<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo文档</a>;做配置,创建测试文章,然后<br><code>hexo g</code>;然后运行<code>hexo d</code>,打开 <code>用户名.github.io</code>看看初步的效果;<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2>我是用的主题是:<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>,具体用法如下:</li></ol><ul><li>进入你的项目文件夹;</li><li><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></li><li>修改配置文件<code>_config.yml</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: yilia</span><br></pre></td></tr></table></figure><ul><li>主题的详细是用查看<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>的<code>README</code>文件.</li><li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">其他主题推荐</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用githubPages&quot;&gt;&lt;a href=&quot;#使用githubPages&quot; class=&quot;headerlink&quot; title=&quot;使用githubPages&quot;&gt;&lt;/a&gt;使用githubPages&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建仓库,仓库名 &lt;code&gt;你的用户名+github.io&lt;/code&gt;;例如我的仓库名是 &lt;code&gt;lance10030.github.io&lt;/code&gt;. 要求源自于 &lt;a href=&quot;https://help.github.com/en/categories/github-pages-basics&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Pages&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;确保本地配置好了&lt;code&gt;github&lt;/code&gt;的&lt;code&gt;ssh&lt;/code&gt;, &lt;a href=&quot;https://juejin.im/post/5ac0a382f265da238533012d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;配置教程&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;项目中配置&lt;code&gt;_config.yml&lt;/code&gt;,示例如下
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="建站" scheme="http://yoursite.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
      <category term="hexo + gihubPage" scheme="http://yoursite.com/tags/hexo-gihubPage/"/>
    
  </entry>
  
</feed>
